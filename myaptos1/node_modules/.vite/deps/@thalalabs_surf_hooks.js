import {
  createEntryPayload
} from "./chunk-SZC4E46P.js";
import {
  useWallet
} from "./chunk-F2HFTGQ7.js";
import "./chunk-KQATBEZ2.js";
import "./chunk-GWNN5Q73.js";
import "./chunk-QRIEPQWS.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/@thalalabs/surf/build/esm/hooks/useSubmitTransaction.js
var import_react = __toESM(require_react(), 1);
var useSubmitTransaction = () => {
  const { connected, signAndSubmitTransaction } = useWallet();
  const [isIdle, setIsIdle] = (0, import_react.useState)(true);
  const [isLoading, setIsLoading] = (0, import_react.useState)(false);
  const [data, setResult] = (0, import_react.useState)();
  const [error, setError] = (0, import_react.useState)();
  const idRef = (0, import_react.useRef)(0);
  function reset() {
    setIsIdle(true);
    setIsLoading(false);
    setResult(void 0);
    setError(void 0);
    idRef.current = idRef.current + 1;
  }
  async function submitTransaction(payload, options) {
    if (connected === false) {
      throw new Error("Wallet is not connected");
    }
    if (signAndSubmitTransaction === void 0) {
      return;
    }
    const id = idRef.current;
    if (!isIdle) {
      throw new Error("Transaction is already in progress");
    }
    setIsLoading(true);
    setIsIdle(false);
    let result;
    try {
      result = await signAndSubmitTransaction({
        data: {
          ...payload,
          functionArguments: payload.functionArguments.map((arg) => {
            if (Array.isArray(arg)) {
              return arg.map((item) => item);
            } else if (typeof arg === "object") {
              throw new Error(`a value of struct type: ${arg} is not supported`);
            } else {
              return arg;
            }
          })
        },
        options
      });
      if (id === idRef.current) {
        setResult(result);
        setIsLoading(false);
      }
    } catch (e) {
      setError(error);
      setIsLoading(false);
      throw e;
    }
    return result;
  }
  return { submitTransaction, reset, isLoading, isIdle, data, error };
};

// node_modules/@thalalabs/surf/build/esm/core/WalletClient.js
var WalletClient = class {
  constructor({ wallet }) {
    Object.defineProperty(this, "wallet", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.wallet = wallet;
  }
  async submitTransaction(payload) {
    var _a;
    return await this.wallet.signAndSubmitTransaction({
      sender: ((_a = this.wallet.account) == null ? void 0 : _a.address) ?? "",
      data: {
        ...payload,
        functionArguments: payload.functionArguments.map((arg) => {
          if (Array.isArray(arg)) {
            return arg.map((item) => item);
          } else if (typeof arg === "object") {
            throw new Error(`a value of struct type: ${arg} is not supported`);
          } else {
            return arg;
          }
        })
      }
    });
  }
  useABI(abi) {
    return new Proxy({}, {
      get: (_, prop) => {
        const functionName = prop.toString();
        return (...args) => {
          const payload = createEntryPayload(abi, {
            function: functionName,
            typeArguments: args[0].type_arguments,
            functionArguments: args[0].arguments
          });
          return this.submitTransaction(payload);
        };
      }
    });
  }
};

// node_modules/@thalalabs/surf/build/esm/hooks/useWalletClient.js
var useWalletClient = () => {
  const wallet = useWallet();
  return {
    connected: wallet.connected,
    client: wallet.connected ? new WalletClient({ wallet }) : void 0
  };
};
export {
  useSubmitTransaction,
  useWalletClient
};
//# sourceMappingURL=@thalalabs_surf_hooks.js.map
